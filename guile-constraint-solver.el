;;; guile-constraint-solver.el --- Emacs integration for Guile Constraint Solver -*- lexical-binding: t; -*-

;; Copyright (C) 2025 dsp-dr

;; Author: dsp-dr
;; Keywords: guile, scheme, z3, lean4, constraint-solving, smt
;; Version: 1.0.0
;; Package-Requires: ((emacs "26.1") (geiser "0.18"))

;;; Commentary:

;; This package provides Emacs integration for the Guile Constraint Solver
;; project, supporting development with Guile Scheme, Z3 SMT solver, and
;; Lean 4 theorem prover.

;;; Code:

(require 'compile)
(require 'geiser nil t)

(defgroup guile-constraint-solver nil
  "Emacs integration for Guile Constraint Solver."
  :group 'languages
  :prefix "gcs-")

(defcustom gcs-project-root nil
  "Root directory of the Guile Constraint Solver project."
  :type 'directory
  :group 'guile-constraint-solver)

(defcustom gcs-guile-command "guile3"
  "Command to run Guile interpreter."
  :type 'string
  :group 'guile-constraint-solver)

(defcustom gcs-z3-command "z3"
  "Command to run Z3 SMT solver."
  :type 'string
  :group 'guile-constraint-solver)

(defcustom gcs-lean-command "lean"
  "Command to run Lean 4."
  :type 'string
  :group 'guile-constraint-solver)

(defcustom gcs-make-command "gmake"
  "Make command to use for building."
  :type 'string
  :group 'guile-constraint-solver)

;;;; Project Detection

(defun gcs-find-project-root (&optional dir)
  "Find the project root starting from DIR (or current directory)."
  (let ((root (locate-dominating-file (or dir default-directory) "setup.org")))
    (when root
      (expand-file-name root))))

(defun gcs-ensure-project-root ()
  "Ensure project root is set, finding it if necessary."
  (unless gcs-project-root
    (setq gcs-project-root (gcs-find-project-root)))
  gcs-project-root)

;;;; Build Integration

(defun gcs-make (target)
  "Run make TARGET in project root."
  (interactive
   (list (completing-read "Make target: "
                          '("help" "setup" "test" "examples" "tutorial"
                            "graph-coloring" "setup-lean4" "clean" "tangle")
                          nil nil "help")))
  (let ((default-directory (gcs-ensure-project-root)))
    (compile (format "%s %s" gcs-make-command target))))

(defun gcs-setup ()
  "Run project setup."
  (interactive)
  (gcs-make "setup"))

(defun gcs-test ()
  "Run all tests."
  (interactive)
  (gcs-make "test"))

(defun gcs-examples ()
  "Run examples."
  (interactive)
  (gcs-make "examples"))

(defun gcs-tutorial ()
  "Run tutorial."
  (interactive)
  (gcs-make "tutorial"))

(defun gcs-clean ()
  "Clean build artifacts."
  (interactive)
  (gcs-make "clean"))

(defun gcs-tangle ()
  "Tangle org files."
  (interactive)
  (gcs-make "tangle"))

;;;; Guile Integration

(defun gcs-run-guile-file ()
  "Run current Guile file."
  (interactive)
  (let ((default-directory (gcs-ensure-project-root)))
    (compile (format "%s -L ./src %s" gcs-guile-command (buffer-file-name)))))

(defun gcs-check-guile-syntax ()
  "Check syntax of current Guile file."
  (interactive)
  (let ((default-directory (gcs-ensure-project-root)))
    (compile (format "%s -L ./src --no-auto-compile -c '(use-modules (%s))'"
                     gcs-guile-command
                     (gcs-buffer-module-name)))))

(defun gcs-buffer-module-name ()
  "Extract module name from current buffer."
  (save-excursion
    (goto-char (point-min))
    (when (re-search-forward "(define-module (\\([^)]+\\))" nil t)
      (match-string 1))))

;;;; Z3 Integration

(defun gcs-run-z3-file ()
  "Run current SMT-LIB2 file with Z3."
  (interactive)
  (compile (format "%s %s" gcs-z3-command (buffer-file-name))))

(defun gcs-create-z3-file ()
  "Create a new Z3 SMT-LIB2 file."
  (interactive)
  (let ((filename (read-file-name "SMT-LIB2 file: " nil nil nil ".smt2")))
    (find-file filename)
    (insert ";; SMT-LIB2 file for Z3\n")
    (insert ";; Generated by guile-constraint-solver.el\n\n")
    (insert "(set-option :produce-models true)\n")
    (insert "(set-logic QF_LIA)\n\n")
    (insert ";; Declarations\n")
    (insert "\n;; Assertions\n")
    (insert "\n(check-sat)\n(get-model)\n")))

;;;; Lean 4 Integration

(defun gcs-run-lean-file ()
  "Run current Lean file."
  (interactive)
  (compile (format "%s %s" gcs-lean-command (buffer-file-name))))

(defun gcs-lean-check ()
  "Check current Lean file."
  (interactive)
  (compile (format "%s --check %s" gcs-lean-command (buffer-file-name))))

(defun gcs-create-lean-file ()
  "Create a new Lean 4 file for constraint problems."
  (interactive)
  (let ((filename (read-file-name "Lean file: " nil nil nil ".lean")))
    (find-file filename)
    (insert "-- Lean 4 file for constraint solving\n")
    (insert "-- Generated by guile-constraint-solver.el\n\n")
    (insert "import Mathlib.Data.Finset.Basic\n")
    (insert "import Mathlib.Tactic\n\n")
    (insert "-- Add your constraint problem here\n")))

;;;; File Templates

(defun gcs-create-constraint-problem ()
  "Create a new constraint problem module."
  (interactive)
  (let* ((name (read-string "Problem name: "))
         (filename (format "src/problems/%s.scm" name))
         (module-name (format "problems %s" name)))
    (find-file filename)
    (insert (format ";;; problems/%s.scm --- %s constraint problem\n\n" name (capitalize name)))
    (insert (format "(define-module (%s)\n" module-name))
    (insert "  #:use-module (srfi srfi-1)\n")
    (insert "  #:use-module (core constraint-engine)\n")
    (insert "  #:use-module (z3 interface)\n")
    (insert (format "  #:export (%s-csp\n" name))
    (insert (format "            %s-z3))\n\n" name))
    (insert (format ";; Native CSP approach\n(define (%s-csp)\n" name))
    (insert "  \"Solve using native constraint solver\"\n")
    (insert "  ;; TODO: Implement CSP solution\n")
    (insert "  #f)\n\n")
    (insert (format ";; Z3 SMT solver approach\n(define (%s-z3)\n" name))
    (insert "  \"Solve using Z3 SMT solver\"\n")
    (insert "  ;; TODO: Implement Z3 solution\n")
    (insert "  #f)\n")))

;;;; Key Bindings

(defvar gcs-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "C-c C-m") 'gcs-make)
    (define-key map (kbd "C-c C-s") 'gcs-setup)
    (define-key map (kbd "C-c C-t") 'gcs-test)
    (define-key map (kbd "C-c C-e") 'gcs-examples)
    (define-key map (kbd "C-c C-u") 'gcs-tutorial)
    (define-key map (kbd "C-c C-c") 'gcs-clean)
    (define-key map (kbd "C-c C-o") 'gcs-tangle)
    map)
  "Keymap for guile-constraint-solver commands.")

(defvar gcs-guile-mode-map
  (let ((map (make-sparse-keymap)))
    (set-keymap-parent map gcs-mode-map)
    (define-key map (kbd "C-c C-r") 'gcs-run-guile-file)
    (define-key map (kbd "C-c C-k") 'gcs-check-guile-syntax)
    (define-key map (kbd "C-c C-n") 'gcs-create-constraint-problem)
    map)
  "Keymap for Guile files in constraint solver project.")

(defvar gcs-z3-mode-map
  (let ((map (make-sparse-keymap)))
    (set-keymap-parent map gcs-mode-map)
    (define-key map (kbd "C-c C-r") 'gcs-run-z3-file)
    (define-key map (kbd "C-c C-n") 'gcs-create-z3-file)
    map)
  "Keymap for Z3 SMT-LIB2 files.")

(defvar gcs-lean-mode-map
  (let ((map (make-sparse-keymap)))
    (set-keymap-parent map gcs-mode-map)
    (define-key map (kbd "C-c C-r") 'gcs-run-lean-file)
    (define-key map (kbd "C-c C-k") 'gcs-lean-check)
    (define-key map (kbd "C-c C-n") 'gcs-create-lean-file)
    map)
  "Keymap for Lean 4 files.")

;;;; Mode Setup

(define-minor-mode gcs-mode
  "Minor mode for Guile Constraint Solver project."
  :lighter " GCS"
  :keymap gcs-mode-map
  (when gcs-mode
    (gcs-ensure-project-root)))

(defun gcs-setup-scheme-mode ()
  "Setup Scheme mode for constraint solver development."
  (when (and (buffer-file-name)
             (string-match-p "/guile-constraint-solver/" (buffer-file-name)))
    (gcs-mode 1)
    (use-local-map gcs-guile-mode-map)
    ;; Geiser configuration
    (when (featurep 'geiser)
      (setq-local geiser-default-implementation 'guile)
      (setq-local geiser-guile-binary gcs-guile-command)
      (setq-local geiser-guile-load-path (list (concat (gcs-ensure-project-root) "src"))))))

(defun gcs-setup-smt-mode ()
  "Setup SMT-LIB2 mode for Z3 files."
  (when (and (buffer-file-name)
             (string-match-p "\\.smt2?$" (buffer-file-name))
             (string-match-p "/guile-constraint-solver/" (buffer-file-name)))
    (gcs-mode 1)
    (use-local-map gcs-z3-mode-map)))

(defun gcs-setup-lean-mode ()
  "Setup Lean mode for theorem proving."
  (when (and (buffer-file-name)
             (string-match-p "\\.lean$" (buffer-file-name))
             (string-match-p "/guile-constraint-solver/" (buffer-file-name)))
    (gcs-mode 1)
    (use-local-map gcs-lean-mode-map)))

;;;; Auto-activation

(add-hook 'scheme-mode-hook #'gcs-setup-scheme-mode)
(add-hook 'find-file-hook #'gcs-setup-smt-mode)
(add-hook 'find-file-hook #'gcs-setup-lean-mode)

;;;; Menu

(easy-menu-define gcs-menu gcs-mode-map
  "Guile Constraint Solver menu"
  '("GCS"
    ["Setup Project" gcs-setup]
    ["Run Tests" gcs-test]
    ["Run Examples" gcs-examples]
    ["Run Tutorial" gcs-tutorial]
    "---"
    ["Create Problem" gcs-create-constraint-problem]
    ["Create Z3 File" gcs-create-z3-file]
    ["Create Lean File" gcs-create-lean-file]
    "---"
    ["Tangle Org Files" gcs-tangle]
    ["Clean Build" gcs-clean]
    "---"
    ["Make..." gcs-make]))

(provide 'guile-constraint-solver)

;;; guile-constraint-solver.el ends here